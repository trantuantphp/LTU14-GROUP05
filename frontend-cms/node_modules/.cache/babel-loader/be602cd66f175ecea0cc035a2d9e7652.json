{"ast":null,"code":"import { unstable_batchedUpdates as r } from \"react-dom\";\nimport { observer as e, useStaticRendering as t, Observer as n } from \"mobx-react-lite\";\nexport { Observer, useAsObservableSource, useLocalStore } from \"mobx-react-lite\";\nimport o, { Component as i, PureComponent as a, forwardRef as c, Children as s, createContext as u, createElement as f } from \"react\";\nimport { createAtom as p, isObservableArray as l, isObservableObject as b, isObservableMap as y, untracked as d, observable as h, configure as m } from \"mobx\";\nvar v = 0,\n    O = {};\n\nfunction g(r) {\n  return O[r] || (O[r] = function (r) {\n    if (\"function\" == typeof Symbol) return Symbol(r);\n    var e = \"__$mobx-react \" + r + \" (\" + v + \")\";\n    return v++, e;\n  }(r)), O[r];\n}\n\nfunction w(r, e) {\n  if (j(r, e)) return !0;\n  if (\"object\" != typeof r || null === r || \"object\" != typeof e || null === e) return !1;\n  var t = Object.keys(r),\n      n = Object.keys(e);\n  if (t.length !== n.length) return !1;\n\n  for (var o = 0; o < t.length; o++) if (!hasOwnProperty.call(e, t[o]) || !j(r[t[o]], e[t[o]])) return !1;\n\n  return !0;\n}\n\nfunction j(r, e) {\n  return r === e ? 0 !== r || 1 / r == 1 / e : r != r && e != e;\n}\n\nvar x = {\n  $$typeof: 1,\n  render: 1,\n  compare: 1,\n  type: 1,\n  childContextTypes: 1,\n  contextType: 1,\n  contextTypes: 1,\n  defaultProps: 1,\n  getDefaultProps: 1,\n  getDerivedStateFromError: 1,\n  getDerivedStateFromProps: 1,\n  mixins: 1,\n  propTypes: 1\n},\n    P = !1,\n    E = g(\"skipRender\"),\n    R = g(\"isForcingUpdate\"),\n    _ = \"function\" == typeof c && c(function (r, e) {}).$$typeof;\n\nfunction A(r, e, t) {\n  Object.hasOwnProperty.call(r, e) ? r[e] = t : Object.defineProperty(r, e, {\n    enumerable: !1,\n    configurable: !0,\n    writable: !0,\n    value: t\n  });\n}\n\nfunction S(r) {\n  P = r, t(r);\n}\n\nfunction C(r, e) {\n  return P && console.warn(\"[mobx-react] It seems that a re-rendering of a React component is triggered while in static (server-side) mode. Please make sure components are rendered only once server-side.\"), this.state !== e || !w(this.props, r);\n}\n\nfunction U(r, e) {\n  var t = g(\"reactProp_\" + e + \"_valueHolder\"),\n      n = g(\"reactProp_\" + e + \"_atomHolder\");\n\n  function o() {\n    return this[n] || A(this, n, p(\"reactive \" + e)), this[n];\n  }\n\n  Object.defineProperty(r, e, {\n    configurable: !0,\n    enumerable: !0,\n    get: function () {\n      return o.call(this).reportObserved(), this[t];\n    },\n    set: function (r) {\n      this[R] || w(this[t], r) ? A(this, t, r) : (A(this, t, r), A(this, E, !0), o.call(this).reportChanged(), A(this, E, !1));\n    }\n  });\n}\n\nfunction T(r) {\n  if (!0 === r.isMobxInjector && console.warn(\"Mobx observer: You are trying to use 'observer' on a component that already has 'inject'. Please apply 'observer' before applying 'inject'\"), _ && r.$$typeof === _) {\n    var t = r.render;\n    if (\"function\" != typeof t) throw new Error(\"render property of ForwardRef was not a function\");\n    return c(function () {\n      var r = arguments;\n      return o.createElement(n, null, function () {\n        return t.apply(void 0, r);\n      });\n    });\n  }\n\n  return \"function\" != typeof r || r.prototype && r.prototype.render || r.isReactClass || i.isPrototypeOf(r) ? function (r) {\n    var e = r.prototype || r;\n    if (e.componentWillReact) throw new Error(\"The componentWillReact life-cycle event is no longer supported\");\n    if (r.__proto__ !== a) if (e.shouldComponentUpdate) {\n      if (e.shouldComponentUpdate !== C) throw new Error(\"It is not allowed to use shouldComponentUpdate in observer based components.\");\n    } else e.shouldComponentUpdate = C;\n    U(e, \"props\"), U(e, \"state\");\n    var t = e.render;\n    return e.render = function () {\n      if (!this.baseRender) {\n        var r = t.bind(this);\n\n        this.baseRender = function () {\n          return r();\n        };\n      }\n\n      return o.createElement(n, null, this.baseRender);\n    }, r;\n  }(r) : e(r);\n}\n\nvar k = {\n  children: !0,\n  key: !0,\n  ref: !0\n},\n    M = u({}),\n    D = function (r) {\n  function e(e, t) {\n    r.call(this, e, t), this.state = Object.assign({}, t, $(e));\n  }\n\n  return r && (e.__proto__ = r), (e.prototype = Object.create(r && r.prototype)).constructor = e, e.prototype.render = function () {\n    return f(M.Provider, {\n      value: this.state\n    }, s.only(this.props.children));\n  }, e.getDerivedStateFromProps = function (r, e) {\n    if (\"production\" !== process.env.NODE_ENV && !w(e, Object.assign({}, e, $(r)))) throw new Error(\"MobX Provider: The set of provided stores has changed. Please avoid changing stores as the change might not propagate to all children\");\n    return e;\n  }, e;\n}(i);\n\nfunction $(r) {\n  var e = {};\n  if (!r) return e;\n\n  for (var t in r) N(t) && (e[t] = r[t]);\n\n  return e;\n}\n\nfunction N(r) {\n  return !k[r] && \"suppressChangedStoreWarning\" !== r;\n}\n\nfunction W(r, e, t, n) {\n  var a = function (r, e) {\n    var t = r.displayName || r.name || r.constructor && r.constructor.name || \"Component\";\n    return e ? \"inject-with-\" + e + \"(\" + t + \")\" : \"inject(\" + t + \")\";\n  }(e, t),\n      c = function (t) {\n    function n() {\n      t.apply(this, arguments);\n    }\n\n    return t && (n.__proto__ = t), (n.prototype = Object.create(t && t.prototype)).constructor = n, n.prototype.render = function () {\n      var t = this.props,\n          n = t.forwardRef,\n          o = function (r, e) {\n        var t = {};\n\n        for (var n in r) Object.prototype.hasOwnProperty.call(r, n) && -1 === e.indexOf(n) && (t[n] = r[n]);\n\n        return t;\n      }(t, [\"forwardRef\"]);\n\n      return Object.assign(o, r(this.context || {}, o) || {}), n && !function (r) {\n        return !(r.prototype && r.prototype.render);\n      }(e) && (o.ref = this.props.forwardRef), f(e, o);\n    }, n;\n  }(i);\n\n  c.contextType = M, n && (c = T(c)), c.isMobxInjector = !0;\n  var s,\n      u,\n      p,\n      l = o.forwardRef(function (r, e) {\n    return o.createElement(c, Object.assign({}, r, {\n      forwardRef: e\n    }));\n  });\n  return s = e, u = l, p = Object.getOwnPropertyNames(Object.getPrototypeOf(s)), Object.getOwnPropertyNames(s).forEach(function (r) {\n    x[r] || p.includes(r) || Object.defineProperty(u, r, Object.getOwnPropertyDescriptor(s, r));\n  }), l.wrappedComponent = e, l.displayName = a, l;\n}\n\nfunction F() {\n  for (var r, e = [], t = arguments.length; t--;) e[t] = arguments[t];\n\n  return \"function\" == typeof arguments[0] ? (r = arguments[0], function (e) {\n    return W(r, e, r.name, !0);\n  }) : function (r) {\n    return W(function (r) {\n      return function (e, t) {\n        return r.forEach(function (r) {\n          if (!(r in t)) {\n            if (!(r in e)) throw new Error(\"MobX injector: Store '\" + r + \"' is not available! Make sure it is provided by some Provider\");\n            t[r] = e[r];\n          }\n        }), t;\n      };\n    }(e), r, e.join(\"-\"), !1);\n  };\n}\n\nD.contextType = M;\nvar I = g(\"disposeOnUnmount\"),\n    q = g(\"originalOnUnmount\");\n\nfunction L(r) {\n  if (\"function\" != typeof r) throw new Error(\"[mobx-react] disposeOnUnmount only works on functions such as disposers returned by reactions, autorun, etc.\");\n}\n\nfunction H(r) {\n  Array.isArray(r) ? r.map(L) : L(r);\n}\n\nfunction X() {\n  var r = this;\n  this[q] && this[q](), this[I] && (this[I].forEach(function (e) {\n    var t = \"string\" == typeof e ? r[e] : e;\n    null != t && (H(t), Array.isArray(t) ? t.map(function (r) {\n      return r();\n    }) : t());\n  }), this[I] = []);\n}\n\nfunction V(r, e) {\n  if (Array.isArray(e)) return e.map(function (e) {\n    return V(r, e);\n  });\n  var t = Object.getPrototypeOf(r).constructor || Object.getPrototypeOf(r.constructor),\n      n = Object.getPrototypeOf(r.constructor);\n  if (t !== i && t !== a && n !== i && n !== a) throw new Error(\"[mobx-react] disposeOnUnmount only supports direct subclasses of React.Component or React.PureComponent.\");\n  \"string\" != typeof e && H(e);\n  var o = !!r[I];\n  return (r[I] || (r[I] = [])).push(e), o || (r.componentWillUnmount && (r[q] = r.componentWillUnmount), Object.defineProperty(r, \"componentWillUnmount\", {\n    get: function () {\n      return X;\n    },\n    set: function (r) {\n      this[I].push(r), this[q] = void 0;\n    },\n    configurable: !1,\n    enumerable: !1\n  })), \"string\" != typeof e ? e : void 0;\n}\n\nfunction Y(r) {\n  function e(e, t, n, o, i, a) {\n    for (var c = [], s = arguments.length - 6; s-- > 0;) c[s] = arguments[s + 6];\n\n    return d(function () {\n      return o = o || \"<<anonymous>>\", a = a || n, null == t[n] ? e ? new Error(\"The \" + i + \" `\" + a + \"` is marked as required in `\" + o + \"`, but its value is `\" + (null === t[n] ? \"null\" : \"undefined\") + \"`.\") : null : r.apply(void 0, [t, n, o, i, a].concat(c));\n    });\n  }\n\n  var t = e.bind(null, !1);\n  return t.isRequired = e.bind(null, !0), t;\n}\n\nfunction z(r) {\n  var e = typeof r;\n  return Array.isArray(r) ? \"array\" : r instanceof RegExp ? \"object\" : function (r, e) {\n    return \"symbol\" === r || \"Symbol\" === e[\"@@toStringTag\"] || \"function\" == typeof Symbol && e instanceof Symbol;\n  }(e, r) ? \"symbol\" : e;\n}\n\nfunction B(r, e) {\n  return Y(function (t, n, o, i, a) {\n    return d(function () {\n      if (r && z(t[n]) === e.toLowerCase()) return null;\n      var i;\n\n      switch (e) {\n        case \"Array\":\n          i = l;\n          break;\n\n        case \"Object\":\n          i = b;\n          break;\n\n        case \"Map\":\n          i = y;\n          break;\n\n        default:\n          throw new Error(\"Unexpected mobxType: \" + e);\n      }\n\n      var c = t[n];\n\n      if (!i(c)) {\n        var s = function (r) {\n          var e = z(r);\n\n          if (\"object\" === e) {\n            if (r instanceof Date) return \"date\";\n            if (r instanceof RegExp) return \"regexp\";\n          }\n\n          return e;\n        }(c),\n            u = r ? \" or javascript `\" + e.toLowerCase() + \"`\" : \"\";\n\n        return new Error(\"Invalid prop `\" + a + \"` of type `\" + s + \"` supplied to `\" + o + \"`, expected `mobx.Observable\" + e + \"`\" + u + \".\");\n      }\n\n      return null;\n    });\n  });\n}\n\nfunction G(r, e) {\n  return Y(function (t, n, o, i, a) {\n    for (var c = [], s = arguments.length - 5; s-- > 0;) c[s] = arguments[s + 5];\n\n    return d(function () {\n      if (\"function\" != typeof e) return new Error(\"Property `\" + a + \"` of component `\" + o + \"` has invalid PropType notation.\");\n      var s = B(r, \"Array\")(t, n, o);\n      if (s instanceof Error) return s;\n\n      for (var u = t[n], f = 0; f < u.length; f++) if ((s = e.apply(void 0, [u, f, o, i, a + \"[\" + f + \"]\"].concat(c))) instanceof Error) return s;\n\n      return null;\n    });\n  });\n}\n\nvar J = {\n  observableArray: B(!1, \"Array\"),\n  observableArrayOf: G.bind(null, !1),\n  observableMap: B(!1, \"Map\"),\n  observableObject: B(!1, \"Object\"),\n  arrayOrObservableArray: B(!0, \"Array\"),\n  arrayOrObservableArrayOf: G.bind(null, !0),\n  objectOrObservableObject: B(!0, \"Object\")\n};\nif (!i) throw new Error(\"mobx-react requires React to be available\");\nif (!h) throw new Error(\"mobx-react requires mobx to be available\");\n\"function\" == typeof r && m({\n  reactionScheduler: r\n});\nexport { T as observer, S as useStaticRendering, D as Provider, M as MobXProviderContext, F as inject, V as disposeOnUnmount, J as PropTypes };","map":null,"metadata":{},"sourceType":"module"}