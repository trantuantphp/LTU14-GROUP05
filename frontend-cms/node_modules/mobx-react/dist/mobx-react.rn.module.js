import{unstable_batchedUpdates as r}from"react-native";import{observer as e,useStaticRendering as t,Observer as n}from"mobx-react-lite";export{Observer,useAsObservableSource,useLocalStore}from"mobx-react-lite";import o,{Component as i,PureComponent as a,forwardRef as c,Children as s,createContext as u,createElement as f}from"react";import{createAtom as p,isObservableArray as l,isObservableObject as b,isObservableMap as y,untracked as d,observable as h,configure as m}from"mobx";var v=0,O={};function g(r){return O[r]||(O[r]=function(r){if("function"==typeof Symbol)return Symbol(r);var e="__$mobx-react "+r+" ("+v+")";return v++,e}(r)),O[r]}function w(r,e){if(j(r,e))return!0;if("object"!=typeof r||null===r||"object"!=typeof e||null===e)return!1;var t=Object.keys(r),n=Object.keys(e);if(t.length!==n.length)return!1;for(var o=0;o<t.length;o++)if(!hasOwnProperty.call(e,t[o])||!j(r[t[o]],e[t[o]]))return!1;return!0}function j(r,e){return r===e?0!==r||1/r==1/e:r!=r&&e!=e}var x={$$typeof:1,render:1,compare:1,type:1,childContextTypes:1,contextType:1,contextTypes:1,defaultProps:1,getDefaultProps:1,getDerivedStateFromError:1,getDerivedStateFromProps:1,mixins:1,propTypes:1},P=!1,E=g("skipRender"),R=g("isForcingUpdate"),_="function"==typeof c&&c(function(r,e){}).$$typeof;function A(r,e,t){Object.hasOwnProperty.call(r,e)?r[e]=t:Object.defineProperty(r,e,{enumerable:!1,configurable:!0,writable:!0,value:t})}function S(r){P=r,t(r)}function C(r,e){return P&&console.warn("[mobx-react] It seems that a re-rendering of a React component is triggered while in static (server-side) mode. Please make sure components are rendered only once server-side."),this.state!==e||!w(this.props,r)}function U(r,e){var t=g("reactProp_"+e+"_valueHolder"),n=g("reactProp_"+e+"_atomHolder");function o(){return this[n]||A(this,n,p("reactive "+e)),this[n]}Object.defineProperty(r,e,{configurable:!0,enumerable:!0,get:function(){return o.call(this).reportObserved(),this[t]},set:function(r){this[R]||w(this[t],r)?A(this,t,r):(A(this,t,r),A(this,E,!0),o.call(this).reportChanged(),A(this,E,!1))}})}function T(r){if(!0===r.isMobxInjector&&console.warn("Mobx observer: You are trying to use 'observer' on a component that already has 'inject'. Please apply 'observer' before applying 'inject'"),_&&r.$$typeof===_){var t=r.render;if("function"!=typeof t)throw new Error("render property of ForwardRef was not a function");return c(function(){var r=arguments;return o.createElement(n,null,function(){return t.apply(void 0,r)})})}return"function"!=typeof r||r.prototype&&r.prototype.render||r.isReactClass||i.isPrototypeOf(r)?function(r){var e=r.prototype||r;if(e.componentWillReact)throw new Error("The componentWillReact life-cycle event is no longer supported");if(r.__proto__!==a)if(e.shouldComponentUpdate){if(e.shouldComponentUpdate!==C)throw new Error("It is not allowed to use shouldComponentUpdate in observer based components.")}else e.shouldComponentUpdate=C;U(e,"props"),U(e,"state");var t=e.render;return e.render=function(){if(!this.baseRender){var r=t.bind(this);this.baseRender=function(){return r()}}return o.createElement(n,null,this.baseRender)},r}(r):e(r)}var k={children:!0,key:!0,ref:!0},M=u({}),D=function(r){function e(e,t){r.call(this,e,t),this.state=Object.assign({},t,$(e))}return r&&(e.__proto__=r),(e.prototype=Object.create(r&&r.prototype)).constructor=e,e.prototype.render=function(){return f(M.Provider,{value:this.state},s.only(this.props.children))},e.getDerivedStateFromProps=function(r,e){if("production"!==process.env.NODE_ENV&&!w(e,Object.assign({},e,$(r))))throw new Error("MobX Provider: The set of provided stores has changed. Please avoid changing stores as the change might not propagate to all children");return e},e}(i);function $(r){var e={};if(!r)return e;for(var t in r)N(t)&&(e[t]=r[t]);return e}function N(r){return!k[r]&&"suppressChangedStoreWarning"!==r}function W(r,e,t,n){var a=function(r,e){var t=r.displayName||r.name||r.constructor&&r.constructor.name||"Component";return e?"inject-with-"+e+"("+t+")":"inject("+t+")"}(e,t),c=function(t){function n(){t.apply(this,arguments)}return t&&(n.__proto__=t),(n.prototype=Object.create(t&&t.prototype)).constructor=n,n.prototype.render=function(){var t=this.props,n=t.forwardRef,o=function(r,e){var t={};for(var n in r)Object.prototype.hasOwnProperty.call(r,n)&&-1===e.indexOf(n)&&(t[n]=r[n]);return t}(t,["forwardRef"]);return Object.assign(o,r(this.context||{},o)||{}),n&&!function(r){return!(r.prototype&&r.prototype.render)}(e)&&(o.ref=this.props.forwardRef),f(e,o)},n}(i);c.contextType=M,n&&(c=T(c)),c.isMobxInjector=!0;var s,u,p,l=o.forwardRef(function(r,e){return o.createElement(c,Object.assign({},r,{forwardRef:e}))});return s=e,u=l,p=Object.getOwnPropertyNames(Object.getPrototypeOf(s)),Object.getOwnPropertyNames(s).forEach(function(r){x[r]||p.includes(r)||Object.defineProperty(u,r,Object.getOwnPropertyDescriptor(s,r))}),l.wrappedComponent=e,l.displayName=a,l}function F(){for(var r,e=[],t=arguments.length;t--;)e[t]=arguments[t];return"function"==typeof arguments[0]?(r=arguments[0],function(e){return W(r,e,r.name,!0)}):function(r){return W(function(r){return function(e,t){return r.forEach(function(r){if(!(r in t)){if(!(r in e))throw new Error("MobX injector: Store '"+r+"' is not available! Make sure it is provided by some Provider");t[r]=e[r]}}),t}}(e),r,e.join("-"),!1)}}D.contextType=M;var I=g("disposeOnUnmount"),q=g("originalOnUnmount");function L(r){if("function"!=typeof r)throw new Error("[mobx-react] disposeOnUnmount only works on functions such as disposers returned by reactions, autorun, etc.")}function H(r){Array.isArray(r)?r.map(L):L(r)}function X(){var r=this;this[q]&&this[q](),this[I]&&(this[I].forEach(function(e){var t="string"==typeof e?r[e]:e;null!=t&&(H(t),Array.isArray(t)?t.map(function(r){return r()}):t())}),this[I]=[])}function V(r,e){if(Array.isArray(e))return e.map(function(e){return V(r,e)});var t=Object.getPrototypeOf(r).constructor||Object.getPrototypeOf(r.constructor),n=Object.getPrototypeOf(r.constructor);if(t!==i&&t!==a&&n!==i&&n!==a)throw new Error("[mobx-react] disposeOnUnmount only supports direct subclasses of React.Component or React.PureComponent.");"string"!=typeof e&&H(e);var o=!!r[I];return(r[I]||(r[I]=[])).push(e),o||(r.componentWillUnmount&&(r[q]=r.componentWillUnmount),Object.defineProperty(r,"componentWillUnmount",{get:function(){return X},set:function(r){this[I].push(r),this[q]=void 0},configurable:!1,enumerable:!1})),"string"!=typeof e?e:void 0}function Y(r){function e(e,t,n,o,i,a){for(var c=[],s=arguments.length-6;s-- >0;)c[s]=arguments[s+6];return d(function(){return o=o||"<<anonymous>>",a=a||n,null==t[n]?e?new Error("The "+i+" `"+a+"` is marked as required in `"+o+"`, but its value is `"+(null===t[n]?"null":"undefined")+"`."):null:r.apply(void 0,[t,n,o,i,a].concat(c))})}var t=e.bind(null,!1);return t.isRequired=e.bind(null,!0),t}function z(r){var e=typeof r;return Array.isArray(r)?"array":r instanceof RegExp?"object":function(r,e){return"symbol"===r||"Symbol"===e["@@toStringTag"]||"function"==typeof Symbol&&e instanceof Symbol}(e,r)?"symbol":e}function B(r,e){return Y(function(t,n,o,i,a){return d(function(){if(r&&z(t[n])===e.toLowerCase())return null;var i;switch(e){case"Array":i=l;break;case"Object":i=b;break;case"Map":i=y;break;default:throw new Error("Unexpected mobxType: "+e)}var c=t[n];if(!i(c)){var s=function(r){var e=z(r);if("object"===e){if(r instanceof Date)return"date";if(r instanceof RegExp)return"regexp"}return e}(c),u=r?" or javascript `"+e.toLowerCase()+"`":"";return new Error("Invalid prop `"+a+"` of type `"+s+"` supplied to `"+o+"`, expected `mobx.Observable"+e+"`"+u+".")}return null})})}function G(r,e){return Y(function(t,n,o,i,a){for(var c=[],s=arguments.length-5;s-- >0;)c[s]=arguments[s+5];return d(function(){if("function"!=typeof e)return new Error("Property `"+a+"` of component `"+o+"` has invalid PropType notation.");var s=B(r,"Array")(t,n,o);if(s instanceof Error)return s;for(var u=t[n],f=0;f<u.length;f++)if((s=e.apply(void 0,[u,f,o,i,a+"["+f+"]"].concat(c)))instanceof Error)return s;return null})})}var J={observableArray:B(!1,"Array"),observableArrayOf:G.bind(null,!1),observableMap:B(!1,"Map"),observableObject:B(!1,"Object"),arrayOrObservableArray:B(!0,"Array"),arrayOrObservableArrayOf:G.bind(null,!0),objectOrObservableObject:B(!0,"Object")};if(!i)throw new Error("mobx-react requires React to be available");if(!h)throw new Error("mobx-react requires mobx to be available");"function"==typeof r&&m({reactionScheduler:r});export{T as observer,S as useStaticRendering,D as Provider,M as MobXProviderContext,F as inject,V as disposeOnUnmount,J as PropTypes};
//# sourceMappingURL=mobx-react.module.js.map
